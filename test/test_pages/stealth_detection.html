<!DOCTYPE html>
<html>
<head>
    <title>OpenWPM Stealth Detection Tests</title>
</head>
<body>
    <h1>Stealth Detection Tests</h1>
    <canvas id="canvas" width="200" height="200"></canvas>
    <div id="results"></div>
    <script>
    /**
     * Detection tests based on Krumnow et al.'s research on detecting OpenWPM.
     * Each test returns true if the browser appears "normal" (undetectable).
     * A stealth-enabled OpenWPM should pass all tests.
     * A regular OpenWPM (with js_instrument) will fail some.
     */
    const results = {};

    // Test 1: navigator.webdriver should be false/undefined in a normal browser
    // Selenium sets this to true by default
    function testWebdriverFlag() {
        return navigator.webdriver !== true;
    }

    // Test 2: Check that common instrumented functions still appear native
    // OpenWPM's legacy JS instrument replaces native functions with JS wrappers
    // which changes their toString() output
    function isNative(fn) {
        try {
            return Function.prototype.toString.call(fn).indexOf("[native code]") !== -1;
        } catch(e) {
            return false;
        }
    }

    function testCanvasFunctionsNative() {
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        return isNative(canvas.toDataURL) &&
               isNative(canvas.getContext) &&
               isNative(ctx.fillText) &&
               isNative(ctx.fillRect);
    }

    // Test 3: Check that Storage functions still appear native
    function testStorageFunctionsNative() {
        return isNative(window.localStorage.getItem) &&
               isNative(window.localStorage.setItem) &&
               isNative(window.sessionStorage.getItem) &&
               isNative(window.sessionStorage.setItem);
    }

    // Test 4: Check Navigator functions still appear native
    function testNavigatorNative() {
        // Check that the getter for userAgent is native
        const desc = Object.getOwnPropertyDescriptor(Navigator.prototype, "userAgent");
        if (!desc || !desc.get) return false;
        return isNative(desc.get);
    }

    // Test 5: Check that no OpenWPM-specific globals are leaked
    function testNoGlobalLeaks() {
        return typeof window.jsInstruments === "undefined" &&
               typeof window.instrumentFingerprintingApis === "undefined" &&
               typeof window.getInstrumentJS === "undefined";
    }

    // Test 6: Check that constructor properties are preserved on instrumented objects
    // OpenWPM's legacy instrument sometimes removes constructors
    function testConstructorsPresent() {
        const canvas = document.getElementById("canvas");
        return typeof canvas.constructor !== "undefined" &&
               typeof canvas.__proto__.constructor !== "undefined" &&
               typeof window.localStorage.constructor !== "undefined" &&
               typeof window.sessionStorage.constructor !== "undefined";
    }

    // Test 7: Check Function.prototype.bind integrity
    // Bot detection uses this as a tamper check
    function testBindIntegrity() {
        if (!Function.prototype.bind) return false;
        try {
            const bindStr = Function.prototype.bind.toString().replace(/bind/g, "Error");
            const errorStr = Error.toString();
            return bindStr === errorStr;
        } catch(e) {
            return false;
        }
    }

    // Test 8: Error stack traces should not contain moz-extension:// URLs
    function testCleanErrorStacks() {
        try {
            // Force an error to capture a stack trace
            null[0]();
        } catch(e) {
            const stack = e.stack || "";
            return stack.indexOf("moz-extension://") === -1;
        }
        return true;
    }

    // Test 9: Check that Object.getOwnPropertyNames doesn't show extra
    // instrumentation properties on prototypes
    function testNoExtraPrototypeProperties() {
        // In a normal browser, CanvasRenderingContext2D.prototype should not
        // have any properties added by instrumentation
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const proto = Object.getPrototypeOf(ctx);
        const propNames = Object.getOwnPropertyNames(proto);
        // Check none of the properties look like OpenWPM instrumentation artifacts
        for (const name of propNames) {
            if (name.startsWith("__openWPM") || name.startsWith("__openwpm")) {
                return false;
            }
        }
        return true;
    }

    // Test 10: Check RTCPeerConnection functions are native (if available)
    function testRTCNative() {
        if (typeof RTCPeerConnection === "undefined") return true;
        return isNative(RTCPeerConnection.prototype.createOffer) &&
               isNative(RTCPeerConnection.prototype.createDataChannel);
    }

    // Run all tests and store results
    results["webdriver_flag"] = testWebdriverFlag();
    results["canvas_functions_native"] = testCanvasFunctionsNative();
    results["storage_functions_native"] = testStorageFunctionsNative();
    results["navigator_native"] = testNavigatorNative();
    results["no_global_leaks"] = testNoGlobalLeaks();
    results["constructors_present"] = testConstructorsPresent();
    results["bind_integrity"] = testBindIntegrity();
    results["clean_error_stacks"] = testCleanErrorStacks();
    results["no_extra_prototype_properties"] = testNoExtraPrototypeProperties();
    results["rtc_native"] = testRTCNative();

    // Write results to DOM for Selenium to read
    const resultsDiv = document.getElementById("results");
    resultsDiv.setAttribute("data-results", JSON.stringify(results));
    resultsDiv.textContent = JSON.stringify(results, null, 2);
    </script>
</body>
</html>
